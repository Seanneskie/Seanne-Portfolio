#!/usr/bin/env node
const fs = require('fs');
const path = require('path');

// directories to ignore during search
const IGNORED_DIRS = new Set(['node_modules', '.git', 'scripts']);

// CSS files generated by Tailwind that are allowed
const ALLOWED_CSS_NAMES = [/^tailwind.*\.css$/i, /^.*output\.css$/i];

const violations = [];

function walk(dir) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const entry of entries) {
    if (IGNORED_DIRS.has(entry.name)) continue;
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      walk(fullPath);
    } else {
      checkFile(fullPath, entry.name);
    }
  }
}

function checkFile(fullPath, name) {
  if (name.endsWith('.css')) {
    const allowed = ALLOWED_CSS_NAMES.some((re) => re.test(name));
    if (!allowed) {
      violations.push(`Unexpected CSS file: ${fullPath}`);
    }
    return;
  }
  if (name.endsWith('.html') || name.endsWith('.js')) {
    const content = fs.readFileSync(fullPath, 'utf8');
    const styleTagRegex = /<style(?![^>]*type=["']text\/tailwindcss["'])/i;
    if (styleTagRegex.test(content)) {
      violations.push(`Inline <style> tag found in: ${fullPath}`);
    }
  }
}

walk(process.cwd());

if (violations.length) {
  console.error('CSS policy violations found:');
  for (const v of violations) console.error(' -', v);
  process.exit(1);
} else {
  console.log('No stray CSS files or <style> tags found.');
}
